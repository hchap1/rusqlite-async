use std::thread::JoinHandle;
use std::thread::spawn;
use std::path::PathBuf;

use async_channel::Sender;
use async_channel::Receiver;
use async_channel::unbounded;

use rusqlite::types::Value;
use rusqlite::Connection;
use rusqlite::params_from_iter;
use rusqlite::ParamsFromIter;
use rusqlite::types::ValueRef;

use crate::error::ChannelError;
use crate::error::Error;
use crate::error::Res;

#[derive(Debug, Clone)]
pub enum ItemStream {
    Value(Vec<DatabaseParam>),
    Error(Error),
    End
}

#[derive(Debug, Clone)]
pub enum InsertMessage {
    // The new row ID, number of rows modified
    Success(usize, usize),
    Error(Error)
}

#[derive(Debug, Clone)]
pub enum ExecuteMessage {
    // Number of rows modified
    Success(usize),
    Error(Error)
}

pub enum DatabaseTask {

    // Cast off an execute request without waiting for it to finish or checking the result
    Execute(&'static str, DatabaseParams),

    // Send an execute request and schedule a callback for the result
    WaitExecute(&'static str, DatabaseParams, Sender<ExecuteMessage>),

    // Send an insert request and schedule a callback for the new ID
    Insert(&'static str, DatabaseParams, Sender<InsertMessage>),

    // Create a query request, echoes results back to the caller
    Query(&'static str, DatabaseParams, Sender<ItemStream>),
}

#[derive(Clone, Debug)]
pub enum DatabaseParam {
    String(String),
    Usize(usize),
    Null,
    F64(f64),
}

impl DatabaseParam {
    fn to_sql(&self) -> Value {
        match self {
            Self::String(v) => Value::from(v.to_owned()),
            Self::Usize(v) => Value::from(*v as isize),
            Self::Null => Value::Null,
            Self::F64(v) => Value::Real(*v),
        }
    }
    
    pub fn usize(&self) -> usize {
        if let Self::Usize(v) = self { return *v; }
        panic!("Attempted to get a USIZE from a non-usize value");
    }

    pub fn string(&self) -> String {
        if let Self::String(v) = self { return v.clone(); }
        panic!("Attempted to get a STRING from a non-string value");
    }

    pub fn f64(&self) -> f64 {
        if let Self::F64(v) = self { return *v; }
        panic!("Attempted to get an F64 from a non-f64 value");
    }
}

pub struct DatabaseParams {
    params: Vec<DatabaseParam>
}

impl DatabaseParams {
    fn to_params(&self) -> ParamsFromIter<Vec<Value>> {
        let params: Vec<Value> = self.params.iter().map(|x| x.to_sql()).collect();
        params_from_iter(params)
    }

    pub fn empty() -> DatabaseParams { DatabaseParams { params: Vec::new() } }
    pub fn new(params: Vec<DatabaseParam>) -> DatabaseParams { DatabaseParams { params } }
    pub fn single(param: DatabaseParam) -> DatabaseParams { DatabaseParams { params: vec![param] } }
}

pub struct Database {
    _handle: JoinHandle<()>,
    datalink: DataLink
}

#[derive(Clone)]
pub struct DataLink {
    task_sender: Sender<DatabaseTask>
}

impl DataLink {
    pub fn new(task_sender: Sender<DatabaseTask>) -> DataLink {
        DataLink { task_sender }
    }

    pub fn execute(&self, query: &'static str, params: DatabaseParams) -> Res<()> {
        self.task_sender.send_blocking(DatabaseTask::Execute(query, params)).map_err(ChannelError::from)?;
        Ok(())
    }

    /// Execute the query and wait for the result. Upon succes, returns the number of affected rows.
    pub async fn execute_and_wait(&self, query: &'static str, params: DatabaseParams) -> Res<usize> {

        let (sender, receiver) = unbounded();
        self.task_sender.send(DatabaseTask::WaitExecute(query, params, sender)).await.map_err(ChannelError::from)?;

        match receiver.recv().await {
            Ok(execute_message) => match execute_message {
                ExecuteMessage::Success(rows_modified) => Ok(rows_modified),
                ExecuteMessage::Error(e) => Err(e)
            },
            Err(e) => Err(ChannelError::from(e).into())
        }
    }

    /// Execute function with receiver callback intended for insert commands (returns row id)
    pub async fn insert(&self, query: &'static str, params: DatabaseParams) -> Res<(usize, usize)> {
        let (sender, receiver) = unbounded();
        self.task_sender.send(DatabaseTask::Insert(query, params, sender)).await.map_err(ChannelError::from)?;

        let result = match receiver.recv().await {
            Ok(result) => result,
            Err(e) => return Err(ChannelError::from(e).into())
        };

        match result {
            InsertMessage::Success(v, n) => Ok((v, n)),
            InsertMessage::Error(e) => Err(e)
        }
    }

    pub fn insert_stream(&self, query: &'static str, params: DatabaseParams) -> Res<Receiver<InsertMessage>> {
        let (sender, receiver) = unbounded();
        self.task_sender.send_blocking(DatabaseTask::Insert(query, params, sender)).map_err(ChannelError::from)?;
        Ok(receiver)
    }

    /// Return a receiver that receives the rows directly. Unblocking.
    pub fn query_stream(&self, query: &'static str, params: DatabaseParams) -> Res<Receiver<ItemStream>> {
        let (sender, receiver) = unbounded();
        self.task_sender.send_blocking(DatabaseTask::Query(query, params, sender)).map_err(ChannelError::from)?;
        Ok(receiver)
    }

    /// Collect all results, then proceed
    pub async fn query_map(
        &self, query: &'static str, params: DatabaseParams
    ) -> Res<Vec<Vec<DatabaseParam>>> {
        let (sender, receiver) = unbounded();
        self.task_sender.send(DatabaseTask::Query(query, params, sender)).await.map_err(ChannelError::from)?;

        let mut values = Vec::new();

        while let Ok(item) = receiver.recv().await {
            match item {
                ItemStream::End => break,
                ItemStream::Error(e) => return Err(e),
                ItemStream::Value(v) => values.push(v)
            };
        }

        Ok(values)
    }
}

impl Database {
    pub fn new(root_dir: PathBuf) -> (Database, Receiver<Error>) {

        let (error_sender, error_receiver) = unbounded();
        let (task_sender, task_receiver) = unbounded();

        (Database {
            _handle: spawn(move || database_thread(root_dir, task_receiver, error_sender)),
            datalink: DataLink::new(task_sender)
        }, error_receiver)
    }

    pub fn derive(&self) -> DataLink {
        self.datalink.clone()
    }
}

fn database_thread(root_dir: PathBuf, task_receiver: Receiver<DatabaseTask>, error_sender: Sender<Error>) {

    let connection = match Connection::open(root_dir.join("data.db")) {
        Ok(connection) => connection,
        Err(_) => return
    };

    'mainloop: loop {
        let current_task = match task_receiver.recv_blocking() {
            Ok(task) => task,
            Err(_) => return
        };

        match current_task {

            // Do not check return.
            DatabaseTask::Execute(query, params) => {
                if let Ok(mut statement) = connection.prepare(query) {
                    let res = statement.execute(params.to_params());
                    if res.is_err() {
                        println!("Execution of SQL query failed. Unable to execute query: {query}");
                    }
                } else {
                    eprintln!("Execution of SQL query failed. Unable to prepare query.");
                }
            },

            DatabaseTask::WaitExecute(query, params, sender) => {

                if let Err(e) = match connection.prepare(query) {
                    Ok(mut statement) => {
                        match statement.execute(params.to_params()) {
                            Ok(rows_modified) => sender.send_blocking(ExecuteMessage::Success(rows_modified)).map_err(ChannelError::from),
                            Err(e) => sender.send_blocking(ExecuteMessage::Error(e.into())).map_err(ChannelError::from)
                        }
                    },
                    Err(e) => sender.send_blocking(ExecuteMessage::Error(e.into())).map_err(ChannelError::from)
                } {
                    match error_sender.send_blocking(e.into()) {
                        Ok(_) => {},
                        Err(e) => eprintln!("Unable to report error: {e:?}. Ensure error receiver is not dropped.")
                    }
                }
            },

            DatabaseTask::Insert(query, params, sender) => {
                match connection.prepare(query) {
                    Ok(mut statement) => {
                        let res = statement.execute(params.to_params());
                        if let Err(e) = match res {
                            Ok(rows_modified) => {
                                let new_id = connection.last_insert_rowid() as usize;
                                sender.send_blocking(InsertMessage::Success(new_id, rows_modified)).map_err(ChannelError::from)
                            },

                            Err(e) => sender.send_blocking(InsertMessage::Error(e.into())).map_err(ChannelError::from)
                        } {
                            match error_sender.send_blocking(e.into()) {
                                Ok(_) => {},
                                Err(e) => eprintln!("Unable to report error: {e:?}. Ensure error receiver is not dropped.")
                            }
                        }
                    }
                    Err(e) => {

                        if let Err(e) = sender.send_blocking(InsertMessage::Error(e.into())).map_err(ChannelError::from) {
                            match error_sender.send_blocking(e.into()) {
                                Ok(_) => {},
                                Err(e) => eprintln!("Unable to report error: {e:?}. Ensure error receiver is not dropped.")
                            }
                        }
                    }
                }
            }
            DatabaseTask::Query(query, params, sender) => {
                let mut statement = match connection.prepare(query) {
                    Ok(statement) => statement,
                    Err(e) => {
                        if let Err(e) = sender.send_blocking(ItemStream::Error(e.into())).map_err(ChannelError::from) {
                            match error_sender.send_blocking(e.into()) {
                                Ok(_) => {},
                                Err(e) => eprintln!("Unable to report error: {e:?}. Ensure error receiver is not dropped.")
                            }
                        }
                        continue
                    }
                };

                let column_count = statement.column_count();
                let rows = match statement.query_map(params.to_params(), |row| {
                    let mut values = Vec::new();

                    'inner: for idx in 0..column_count {
                        let value = match row.get_ref(idx) {
                            Ok(value) => value,
                            Err(_) => continue 'inner
                        };

                        let value = match value {
                            ValueRef::Null => DatabaseParam::Null,
                            ValueRef::Integer(i) => DatabaseParam::Usize(i as usize),
                            ValueRef::Real(f) => DatabaseParam::F64(f),
                            ValueRef::Text(s) => DatabaseParam::String(String::from_utf8_lossy(s).into_owned()),
                            ValueRef::Blob(_) => DatabaseParam::Null,
                        };

                        values.push(value);
                    }

                    if column_count == values.len() { Ok(values) }
                    else { Err(rusqlite::Error::QueryReturnedNoRows) }
                }) {
                    Ok(rows) => rows.filter_map(|x| x.ok()).collect::<Vec<Vec<DatabaseParam>>>(),
                    Err(e) => {
                        if let Err(e) = sender.send_blocking(ItemStream::Error(e.into())).map_err(ChannelError::from) {
                            match error_sender.send_blocking(e.into()) {
                                Ok(_) => {},
                                Err(e) => eprintln!("Unable to report error: {e:?}. Ensure error receiver is not dropped.")
                            }
                        }
                        continue 'mainloop
                    }
                };

                for row in rows {
                    if let Err(e) = sender.send_blocking(ItemStream::Value(row)).map_err(ChannelError::from) {
                        match error_sender.send_blocking(e.into()) {
                            Ok(_) => {},
                            Err(e) => eprintln!("Unable to report error: {e:?}. Ensure error receiver is not dropped.")
                        }
                    }
                }

                if let Err(e) = sender.send_blocking(ItemStream::End).map_err(ChannelError::from) {
                    match error_sender.send_blocking(e.into()) {
                        Ok(_) => {},
                        Err(e) => eprintln!("Unable to report error: {e:?}. Ensure error receiver is not dropped.")
                    }
                }
            }
        }
    }
}
